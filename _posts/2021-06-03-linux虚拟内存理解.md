---
layout:     post
title:      "linux虚拟内存理解"
subtitle:   "虚拟内存理解以及虚拟内存到物理内存的映射"
author:     "gdream"
header-img: "img/post-bg-2021.jpg"
mathjax: true
catalog: true
tags:
    - linux
---

> 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存(一个连续完整的地址空间), 而实际上它通常是被分隔成多个物理内存碎片,还有部分暂时存储在外部磁盘存储器上,在需要时进行数据交换。目前,大多数操作系统都使用了虚拟内存,如Windows家族的“虚拟内存”；Linux的“交换空间”等。 ----*来自百度百科*。


# linux虚拟内存理解
## 什么是虚拟内存
虚拟内存(Virtual Memory)顾名思义它不是真实的内存，而是操作系统虚拟出来的一份与物理内存相对应的地址空间。当程序对内存进行读写的时候，它使用的就是虚拟地址，然后由操作系统将虚拟地址映射到物理地址。通过虚拟地址访问内存有以下优点：
- 程序可以使用一系列连续的的虚拟地址来访问物理内存中不连续的大内存缓冲区；
- 程序可以使用虚拟地址访问大于可用物理内存的内存缓冲区。当物理内存不够的时候，内存管理器(MMU)会将物理内存页(大小通常为4K)保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动；
- 不同进程的虚拟地址映射到的物理内存彼此隔离，一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存；

## linux内存分配方式
linux内存分配方式一般包括两种：线性分配器和空闲链表分配器。

### 线性分配器
当我们使用线性分配器时，只需要在内存中维护一个指向内存特定位置的指针，如果用户程序向分配器申请内存，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中指针：
![图 1 线性分配器](/img/linux-virtual-memory/bump-allocator.png)  
**图 1 线性分配器**

线性分配器虽然高效，但是有较大的局限性,虽然线性分配器实现为它带来了较快的执行速度以及较低的实现复杂度，但是线性分配器无法在内存被释放时重用内存。因为线性分配器具有上述特性，所以需要与合适的垃圾回收算法配合使用，例如：标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法，它们可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。

### 空闲链表分配器
空闲链表分配器（Free-List Allocator）可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：
![图 2 空闲链表分配器](/img/linux-virtual-memory/free-list-allocator.png)  
**图 2 空闲链表分配器**

因为不同的内存块通过指针构成了链表，所以使用这种方式的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度是 𝑂(𝑛)。空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择，最常见的是以下四种：
- 首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；
- 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；
- 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；
- 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；

## 
通常，当我们执行一个程序时，系统会做一些初始化的工作：

- 创建一个独立的虚拟地址空间，但是并不设置与物理内存的映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置；
- 读取可执行文件头，并建立虚拟空间与可执行文件的映射关系；
- 将 CPU 指令寄存器设置为可执行文件入口，启动运行。
- 在 Linux 中，虚拟空间与可执行文件的这种映射关系保存在操作系统内部的一个数据结构中，Linux 将进程虚拟地址空间的一个段叫做虚拟内存区域（VMA, Virtual Memory Area）。
  
比如进程被创建后，操作系统可能会在进程相对应的数据结构中设置一个`.text`段的VMA, 一个`.data`段的VMA和一个`.bss`段的VMA。`Text Segment`是存放二进制可执行代码的位置，`Data Segment`存放静态常量，`BSS Segment`存放未初始化的静态变量。接下来是堆（Heap）段。堆是往高地址增长的，是用来动态分配内存的区域，malloc就是在这里面分配的。接下来的区域是Memory Mapping Segment。这块地址可以用来把文件映射进内存用的，如果二进制的执行文件依赖于某个动态链接库，就是在这个区域里面将so文件映射到了内存中。再下面就是栈（Stack）地址段。主线程的函数调用的函数栈就是用这里的。
![virtual-memory-address](/img/linux-virtual-memory/virtual-memory-address.jpeg)
**图3 虚拟地址空间分布**

## 虚拟地址到物理地址的转换
linux将虚拟地址转换成物理地址有两种方式：分段和分页。

### 分段寻址
分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。虚拟地址中的段内偏移量应该位于0和段界限之间。如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。
![图4](/img/linux-virtual-memory/segment.jpeg)
**图4 分段寻址** 
在Linux操作系统中，并没有使用到全部的分段功能。那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态DPL是3，内核态DPL是0。当用户态试图访问内核态的时候，会因为权限不足而报错。

### 分页寻址
其实Linux倾向于另外一种从虚拟地址到物理地址的转换方式，称为分页（Paging）。
对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出。一旦需要的时候，再加载进来，叫作换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。这个换入和换出都是以页为单位的。页面的大小一般为4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，组成线性地址，就能对于内存中的每个位置进行访问了。
![图5](/img/linux-virtual-memory/page.jpeg)
**图5 四层页表结构** 

全局目录项 `PGD(Page Global Directory)`、上层页目录项 `PUD(Page Upper Directory)`、中间页目录项 `PMD(Page Middle Directory)`和页表项 `PTE(Page Table Entry)`每个都是9个bit组成，前三层每一项的值都是在该项的偏移值，页表项中存的是对应物理页的首地址，页内偏移地址是由12个bit组成。物理页首地址加上页内偏移量就可以找到具体的物理地址了。
由于页表项是9个bit，那么一个页表项能表示的物理地址大小为 $2^9 * 4K = 2M$, 如果是64位系统的话，一个页表项占用的内存为 $2^9 * 8 = 4K$, 也就是说虚拟地址使用$4K$大小的空间表示了$2M$ 的实际物理地址。同理一个`PMD`能代表的大小为 $2^9 * 2M = 1G$, 以此类推虚拟地址最大能代表的物理空间地址是非常巨大的。 由于只有`PGD`需要在程序启动的时候申请出来，其它页都是等到触发缺页中断的时候才会申请出来，所以不需要担心整个四层页表都申请出来占用太大的内存。 那么什么时候会触发缺页中断呢？ 
**缺页中断**指的是当软件试图访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。虽然其名为“页缺失”错误，但实际上这并不一定是一种错误。而且这一机制对于利用虚拟内存来增加程序可用内存空间的操作系统（比如Microsoft Windows和各种类Unix系统）中都是常见且有必要的。

### x86机器的寻址方式
X86体系处理器采用了此种转换结构，包括32位和64位地址模式。X86给每个进程分配一个GDT（Global Descriptor Table，相当于一个段表），每个元素包含某一个多层页表的地址和对应的长度。每个进程只用少量的段，所以段表会非常小，对段表的索引是隐含在指令里面的，比如push、pop则去栈段，分支指令则对代码段等，不需要bit位去索引。
![图6](/img/linux-virtual-memory/segment-page.jpeg)
**图6 段表-页表结构** 

64位X86，虚拟地址空间可以延伸到64位，为了简化地址转换，当前很多处理器只用了48位（前16位没有使用），能够满足256TB的内存空间使用，采用段表和4层页表进行转换（9个bit位+9个bit位+9个bit位+9个bit位 + 12个bit位，段表不需要bit位索引，前4个9bit位分别用于4层页表的索引，最后一个12bit用于页内偏移，总计48bit位），只有第一层页表是被填满的，其他三层页表只有对应虚拟空间地址被使用了才会被填充。为了优化，64位X86可以消除1个或者2个层级的页表。每个物理页的大小是4KB，第4层级的页表可以管理2MB，第3层级的页表可以管理1GB的数据，若操作系统分配了连续的2MB物理页，则可以省去第4层级的页表，让第三层的页表元素直接指向2MB的物理页，同样的，若操作系统分配了连续的1GB物理页，则可以省去第3、4层级的页表，让第2层级页表的元素直接指向1GB的物理页。这样做既可以节省页表存储的开销，还可以提高地址转换效率。

### 提高寻址速度
上面提到的多层级页表，若都需要到内存里面访问，单是将虚拟地址转成物理地址就需要2~4次物理内存访问，这要比执行一条指令的耗时高很多，显然是不切实际的。下面讲一下有哪些措施可以提高转换效率：
- TLB(Translation lookaside buffer)，TLB通常和处理器在一起，查找速度非常快，包含多级TLB，第一级TLB容量小、速度快，第二级TLB容量大、速度比第一级慢一些。`Virtual Page Number`和TLB中所有的元素同时进行比较，若匹配，则得到对应的`Physical Page Frame Number`以及对应的访问权限，若没有匹配，则按照段表+多层页表的方式去重新查找，找到后将转换结果保存到TLB（若已满，则按照一定策略进行替换）。
- Superpages, 超级页面是物理内存中映射虚拟内存中相邻区域的一组相邻页
- 虚拟地址Cache, 将虚拟地址以及对应的物理内存内容缓存起来，在TLB查找之前先去这个缓存进行查看，若匹配则直接将对应的内容给到处理器，这样就省去了地址转换以及从物理内存提取内容的过程。现代多核处理器给每个核都配备了这样一个芯片上缓存，每个缓存分成两部分，一部分用于指令，一部分用于数据。
- 物理地址Cache, 许多处理器架构会在虚拟地址Cache和TLB之后设置一个物理地址Cache，保存物理地址和对应内容的映射，当经过TLB或者硬件Page Table转换后得到对应的物理地址，先去这个Cache查询，若匹配则直接获取其中的内容，免去了一次物理内存的访问，加快了内容的访问速度。

## 页大小为什么是4K
我们都知道 Linux 会以页为单位管理内存，无论是将磁盘中的数据加载到内存中，还是将内存中的数据写回磁盘，操作系统都会以页面为单位进行操作，哪怕我们只向磁盘中写入一个字节的数据，我们也需要将整个页面中的全部数据刷入磁盘中。页面大小的设置要考虑下面的因素：
- 过小的页面大小会带来较大的页表项增加寻址时 TLB（Translation lookaside buffer）的查找时间和额外开销；
- 过大的页面大小会浪费内存空间，造成内存碎片，降低内存的利用率；
4KB 的内存页是上个世纪决定的默认设置，那么为什么选择4KB呢，详情可参考[为什么 Linux 默认页大小是 4KB](https://draveness.me/whys-the-design-linux-default-page/)

## 参考
- https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces
- https://rcore-os.github.io/rCore-Tutorial-deploy/docs/lab-3/guide/part-1.html
- https://maodanp.github.io/2019/06/02/linux-virtual-space/
- https://draveness.me/whys-the-design-linux-default-page/
- *趣谈Linux操作系统*
- https://zhuanlan.zhihu.com/p/103941006